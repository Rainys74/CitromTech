#include <metal_stdlib>
#include <metal_texture>
using namespace metal;

#if !(__HAVE_FMA__)
#define fma(a,b,c) ((a) * (b) + (c))
#endif

#ifndef XLT_REMAP_O
	#define XLT_REMAP_O {0, 1, 2, 3, 4, 5, 6, 7}
#endif
constexpr constant uint xlt_remap_o[] = XLT_REMAP_O;
struct Matrices_Type
{
    float4x4 transform;
    float3 cameraLocalPos;
};

struct base_Type
{
    float3 color;
    float intensity;
};

struct directionalLights_Type
{
    base_Type base;
    float3 direction;
    float padding1;
};

struct skyLight_Type
{
    base_Type base;
};

struct Lighting_Type
{
    directionalLights_Type directionalLights[2];
    uint directionalLightCount;
    skyLight_Type skyLight;
};

struct Mtl_FragmentIn
{
    float2 TexCoord0 [[ user(TexCoord0) ]] ;
    float3 Normal0 [[ user(Normal0) ]] ;
    float3 LocalPosition0 [[ user(LocalPosition0) ]] ;
};

struct Mtl_FragmentOut
{
    float4 SV_Target0 [[ color(xlt_remap_o[0]) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Matrices_Type& Matrices [[ buffer(0) ]],
    constant Lighting_Type& Lighting [[ buffer(1) ]],
    sampler samplerTex [[ sampler (0) ]],
    texture2d<float, access::sample > tex [[ texture(0) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    //--- Start Early Main ---
    float4 u_xlat0;
    int4 u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat3;
    bool u_xlatb4;
    float u_xlat9;
    //--- End Early Main ---
    //ADD
    u_xlat0.xyz = (-input.LocalPosition0.xyz) + Matrices.cameraLocalPos.xyzx.xyz;
    //DP3
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    //RSQ
    u_xlat9 = rsqrt(u_xlat9);
    //MAD
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat9), (-Lighting.directionalLights[0].direction.xyzx.xyz));
    //DP3
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    //RSQ
    u_xlat9 = rsqrt(u_xlat9);
    //MUL
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    //DP3
    u_xlat0.x = dot(input.Normal0.xyz, u_xlat0.xyz);
    //LOG
    u_xlat3 = log2(abs(u_xlat0.x));
    //LT
    u_xlatb0 = 0.0<u_xlat0.x;
    //MUL
    u_xlat3 = u_xlat3 * 255.0;
    //EXP
    u_xlat3 = exp2(u_xlat3);
    //MOV
    u_xlat1.x = Lighting.directionalLights[0].base.color.xyzx.x;
    //MOV
    u_xlat1.y = float(0.0);
    //MOV
    u_xlat1.z = float(0.0);
    //MOV
    u_xlat1.w = float(1.0);
    //MUL
    u_xlat1.xw = float2(u_xlat3) * u_xlat1.xw;
    //AND
    u_xlati0 = int4((uint4(bool4(u_xlatb0)) * 0xffffffffu) & as_type<uint4>(u_xlat1));
    //DP3
    u_xlat1.x = dot(input.Normal0.xyz, input.Normal0.xyz);
    //RSQ
    u_xlat1.x = rsqrt(u_xlat1.x);
    //MUL
    u_xlat1.xyz = u_xlat1.xxx * input.Normal0.xyz;
    //DP3
    u_xlat1.x = dot(u_xlat1.xyz, (-Lighting.directionalLights[0].direction.xyzx.xyz));
    //LT
    u_xlatb4 = 0.0<u_xlat1.x;
    //AND
    u_xlat0 = select(float4(0.0, 0.0, 0.0, 0.0), as_type<float4>(u_xlati0), bool4(bool4(u_xlatb4)));
    //MOV
    u_xlat2.xyz = Lighting.directionalLights[0].base.color.xyzx.xyz;
    //MOV
    u_xlat2.w = 1.0;
    //MUL
    u_xlat2 = u_xlat2 * float4(Lighting.directionalLights[0].base.intensity);
    //MUL
    u_xlat2 = u_xlat1.xxxx * u_xlat2;
    //AND
    u_xlat1 = select(float4(0.0, 0.0, 0.0, 0.0), u_xlat2, bool4(bool4(u_xlatb4)));
    //ADD
    u_xlat2.w = u_xlat0.w + u_xlat1.w;
    //ADD
    u_xlat2.xyz = u_xlat1.xyz + Lighting.skyLight.base.color.xyzx.xyz;
    //MOV
    u_xlat0.w = 1.0;
    //ADD
    u_xlat0 = u_xlat0 + u_xlat2;
    u_xlat0 = clamp(u_xlat0, 0.0f, 1.0f);
    //SAMPLE
    u_xlat1 = tex.sample(samplerTex, input.TexCoord0.xy);
    //MUL
    output.SV_Target0 = u_xlat0 * u_xlat1;
    //RET
    return output;
}
