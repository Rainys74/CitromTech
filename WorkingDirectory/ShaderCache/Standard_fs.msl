#include <metal_stdlib>
#include <metal_texture>
using namespace metal;

#if !(__HAVE_FMA__)
#define fma(a,b,c) ((a) * (b) + (c))
#endif

#ifndef XLT_REMAP_O
	#define XLT_REMAP_O {0, 1, 2, 3, 4, 5, 6, 7}
#endif
constexpr constant uint xlt_remap_o[] = XLT_REMAP_O;
struct CBuffer1_Type
{
    float4x4 transform;
    float3 cameraLocalPos;
};

struct base_Type
{
    float3 color;
    float intensity;
};

struct skyLight_Type
{
    base_Type base;
};

struct directionalLights_Type
{
    base_Type base;
    float3 direction;
};

struct Lighting_Type
{
    skyLight_Type skyLight;
    directionalLights_Type directionalLights[2];
};

struct Mtl_FragmentIn
{
    float2 TexCoord0 [[ user(TexCoord0) ]] ;
    float3 Normal0 [[ user(Normal0) ]] ;
    float3 LocalPosition0 [[ user(LocalPosition0) ]] ;
};

struct Mtl_FragmentOut
{
    float4 SV_Target0 [[ color(xlt_remap_o[0]) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant CBuffer1_Type& CBuffer1 [[ buffer(0) ]],
    constant Lighting_Type& Lighting [[ buffer(1) ]],
    sampler samplerTex [[ sampler (0) ]],
    texture2d<float, access::sample > tex [[ texture(0) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    //--- Start Early Main ---
    float4 u_xlat0;
    int3 u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat9;
    //--- End Early Main ---
    //ADD
    u_xlat0.xyz = (-input.LocalPosition0.xyz) + CBuffer1.cameraLocalPos.xyzx.xyz;
    //DP3
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    //RSQ
    u_xlat9 = rsqrt(u_xlat9);
    //MAD
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat9), (-Lighting.directionalLights[0].direction.xyzx.xyz));
    //DP3
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    //RSQ
    u_xlat9 = rsqrt(u_xlat9);
    //MUL
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    //DP3
    u_xlat0.x = dot(input.Normal0.xyz, u_xlat0.xyz);
    //LOG
    u_xlat3.x = log2(abs(u_xlat0.x));
    //LT
    u_xlatb0 = 0.0<u_xlat0.x;
    //MUL
    u_xlat3.x = u_xlat3.x * 255.0;
    //EXP
    u_xlat3.x = exp2(u_xlat3.x);
    //MUL
    u_xlat3.xyz = u_xlat3.xxx * float3(1.0, 0.0, 0.0);
    //AND
    u_xlati0.xyz = int3((uint3(bool3(u_xlatb0)) * 0xffffffffu) & as_type<uint3>(u_xlat3.xyz));
    //DP3
    u_xlat9 = dot(input.Normal0.xyz, input.Normal0.xyz);
    //RSQ
    u_xlat9 = rsqrt(u_xlat9);
    //MUL
    u_xlat1.xyz = float3(u_xlat9) * input.Normal0.xyz;
    //DP3
    u_xlat9 = dot(u_xlat1.xyz, (-Lighting.directionalLights[0].direction.xyzx.xyz));
    //LT
    u_xlatb1 = 0.0<u_xlat9;
    //AND
    u_xlat9 = u_xlatb1 ? u_xlat9 : float(0.0);
    //AND
    u_xlat1.xyz = select(float3(0.0, 0.0, 0.0), as_type<float3>(u_xlati0.xyz), bool3(bool3(u_xlatb1)));
    //ADD
    u_xlat2.w = u_xlat9 + u_xlat1.x;
    //ADD
    u_xlat2.xyz = float3(u_xlat9) + Lighting.skyLight.base.color.xyzx.xyz;
    //MOV
    u_xlat1.w = 1.0;
    //ADD
    u_xlat0 = u_xlat1 + u_xlat2;
    u_xlat0 = clamp(u_xlat0, 0.0f, 1.0f);
    //SAMPLE
    u_xlat1 = tex.sample(samplerTex, input.TexCoord0.xy);
    //MUL
    output.SV_Target0 = u_xlat0 * u_xlat1;
    //RET
    return output;
}
